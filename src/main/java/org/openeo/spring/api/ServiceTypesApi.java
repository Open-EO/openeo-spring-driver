/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.0.0-SNAPSHOT).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openeo.spring.api;

import org.openeo.spring.model.Error;
import org.openeo.spring.model.ServiceType;
import io.swagger.annotations.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2020-06-30T15:12:47.411+02:00[Europe/Rome]")
@Validated
@Api(value = "service_types", description = "the service_types API")
public interface ServiceTypesApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * GET /service_types : Supported secondary web service protocols
     * The request will ask the back-end for supported secondary web service protocols, e.g. WMS or WCS. The response is an object of all available secondary web service protocols,supported configuration settings and process parameters.  Configuration settings for the service need to be defined upon creation of a service and the service will be set up accordingly.  A list of process parameters is also available. This parameters can be used by users in a user-defined process that is used to compute web service results. The objects can directly be used inside the process graph with  a &#x60;from_parameter&#x60; reference. Such parameters are usually things that have to be injected into the user-defined process from the context of the web service during runtime. For example, a map service such as a WMS would need to inject the spatial extent into the user-defined process so that the back-end can compute the corresponding tile correctly.  To improve interoperability between back-ends common names for the services SHOULD be used, e.g. the abbreviations used in the official [OGC Schema Repository](http://schemas.opengis.net/) for the respective services.  Service names are allowed to be *case insensitive* throughout the API.
     *
     * @return An object with a map containing all service names as keys and an object that defines supported configuration settings and process parameters. (status code 200)
     *         or The request can&#39;t be fulfilled due to an error on client-side, i.e. the request is invalid. The client should not repeat the request without modifications.  The response body SHOULD contain a JSON error object. MUST be any HTTP status code specified in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6.6). This request usually does not respond with HTTP status codes 401 and 403 due to missing authorization. HTTP status code 404 should be used if the value of a path parameter is invalid.  See also: * [Error Handling](#section/API-Principles/Error-Handling) in the API in general. * [Common Error Codes](errors.json) (status code 400)
     *         or The request can&#39;t be fulfilled due to an error at the back-end. The error is never the client’s fault and therefore it is reasonable for the client to retry the exact same request that triggered this response.  The response body SHOULD contain a JSON error object. MUST be any HTTP status code specified in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6.6).  See also: * [Error Handling](#section/API-Principles/Error-Handling) in the API in general. * [Common Error Codes](errors.json) (status code 500)
     */
    @ApiOperation(value = "Supported secondary web service protocols", nickname = "listServiceTypes", notes = "The request will ask the back-end for supported secondary web service protocols, e.g. WMS or WCS. The response is an object of all available secondary web service protocols,supported configuration settings and process parameters.  Configuration settings for the service need to be defined upon creation of a service and the service will be set up accordingly.  A list of process parameters is also available. This parameters can be used by users in a user-defined process that is used to compute web service results. The objects can directly be used inside the process graph with  a `from_parameter` reference. Such parameters are usually things that have to be injected into the user-defined process from the context of the web service during runtime. For example, a map service such as a WMS would need to inject the spatial extent into the user-defined process so that the back-end can compute the corresponding tile correctly.  To improve interoperability between back-ends common names for the services SHOULD be used, e.g. the abbreviations used in the official [OGC Schema Repository](http://schemas.opengis.net/) for the respective services.  Service names are allowed to be *case insensitive* throughout the API.", response = ServiceType.class, responseContainer = "Map", authorizations = {
        @Authorization(value = "Bearer")
    }, tags={ "Capabilities","Secondary Services", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "An object with a map containing all service names as keys and an object that defines supported configuration settings and process parameters.", response = ServiceType.class, responseContainer = "Map"),
        @ApiResponse(code = 400, message = "The request can't be fulfilled due to an error on client-side, i.e. the request is invalid. The client should not repeat the request without modifications.  The response body SHOULD contain a JSON error object. MUST be any HTTP status code specified in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6.6). This request usually does not respond with HTTP status codes 401 and 403 due to missing authorization. HTTP status code 404 should be used if the value of a path parameter is invalid.  See also: * [Error Handling](#section/API-Principles/Error-Handling) in the API in general. * [Common Error Codes](errors.json)", response = Error.class),
        @ApiResponse(code = 500, message = "The request can't be fulfilled due to an error at the back-end. The error is never the client’s fault and therefore it is reasonable for the client to retry the exact same request that triggered this response.  The response body SHOULD contain a JSON error object. MUST be any HTTP status code specified in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6.6).  See also: * [Error Handling](#section/API-Principles/Error-Handling) in the API in general. * [Common Error Codes](errors.json)", response = Error.class) })
    @RequestMapping(value = "/service_types",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    default ResponseEntity<Map<String, ServiceType>> listServiceTypes() {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"WMS\" : { \"title\" : \"OGC Web Map Service\", \"configuration\" : { \"version\" : { \"type\" : \"string\", \"description\" : \"The WMS version offered to consumers of the service.\", \"default\" : \"1.3.0\", \"enum\" : [ \"1.1.1\", \"1.3.0\" ] } }, \"process_parameters\" : [ { \"name\" : \"layer\", \"description\" : \"The layer name.\", \"schema\" : { \"type\" : \"string\" }, \"default\" : \"roads\" }, { \"name\" : \"spatial_extent_west\", \"description\" : \"The lower left corner for coordinate axis 1 of the extent currently shown to the consumer.\", \"schema\" : { \"type\" : \"number\" } }, { \"name\" : \"spatial_extent_south\", \"description\" : \"The lower left corner for coordinate axis 2 of the extent currently shown to the consumer.\", \"schema\" : { \"type\" : \"number\" } }, { \"name\" : \"spatial_extent_east\", \"description\" : \"The upper right corner for coordinate axis 1 of the extent currently shown to the consumer.\", \"schema\" : { \"type\" : \"number\" } }, { \"name\" : \"spatial_extent_north\", \"description\" : \"The upper right corner for coordinate axis 2 of the extent currently shown to the consumer.\", \"schema\" : { \"type\" : \"number\" } } ], \"links\" : [ { \"href\" : \"https://www.opengeospatial.org/standards/wms\", \"rel\" : \"about\", \"title\" : \"OGC Web Map Service Standard\" } ] }, \"WFS\" : { \"title\" : \"OGC Web Feature Service\", \"description\" : \"Exposes a OGC-compliant WFS service. Note: This is NOT compliant to OGC API - Features.\", \"configuration\" : { \"version\" : { \"type\" : \"string\", \"description\" : \"The WFS version offered to consumers of the service.\", \"default\" : \"2.0.0\", \"enum\" : [ \"1.0.0\", \"1.1.0\", \"2.0.0\" ] }, \"maxFeatures\" : { \"type\" : \"integer\", \"description\" : \"Maximum number of features (since WFS 2.0.0 only).\", \"default\" : 10000, \"minimum\" : 1, \"maximum\" : 100000 } }, \"links\" : [ { \"href\" : \"https://www.opengeospatial.org/standards/wfs\", \"rel\" : \"about\", \"title\" : \"OGC Web Feature Service Standard\" } ] } }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
