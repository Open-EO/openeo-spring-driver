[
{
    "id": "load_collection",
    "summary": "Load a collection",
    "description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension labels) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
    "categories": [
        "cubes",
        "import"
    ],
    "parameters": [
        {
            "name": "id",
            "description": "The collection id.",
            "schema": {
                "type": "string",
                "subtype": "collection-id",
                "pattern": "^[\\w\\-\\.~/]+$"
            }
        },
        {
            "name": "spatial_extent",
            "description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
            "schema": [
                {
                    "title": "Bounding Box",
                    "type": "object",
                    "subtype": "bounding-box",
                    "required": [
                        "west",
                        "south",
                        "east",
                        "north"
                    ],
                    "properties": {
                        "west": {
                            "description": "West (lower left corner, coordinate axis 1).",
                            "type": "number"
                        },
                        "south": {
                            "description": "South (lower left corner, coordinate axis 2).",
                            "type": "number"
                        },
                        "east": {
                            "description": "East (upper right corner, coordinate axis 1).",
                            "type": "number"
                        },
                        "north": {
                            "description": "North (upper right corner, coordinate axis 2).",
                            "type": "number"
                        },
                        "base": {
                            "description": "Base (optional, lower left corner, coordinate axis 3).",
                            "type": [
                                "number",
                                "null"
                            ],
                            "default": null
                        },
                        "height": {
                            "description": "Height (optional, upper right corner, coordinate axis 3).",
                            "type": [
                                "number",
                                "null"
                            ],
                            "default": null
                        },
                        "crs": {
                            "description": "Coordinate reference system of the extent, specified as as [EPSG code](http://www.epsg-registry.org/), [WKT2 (ISO 19162) string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html) or [PROJ definition (deprecated)](https://proj.org/usage/quickstart.html). Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                            "anyOf": [
                                {
                                    "title": "EPSG Code",
                                    "type": "integer",
                                    "subtype": "epsg-code",
                                    "minimum": 1000,
                                    "examples": [
                                        3857
                                    ]
                                },
                                {
                                    "title": "WKT2",
                                    "type": "string",
                                    "subtype": "wkt2-definition"
                                },
                                {
                                    "title": "PROJ definition",
                                    "type": "string",
                                    "subtype": "proj-definition",
                                    "deprecated": true
                                }
                            ],
                            "default": 4326
                        }
                    }
                },
                {
                    "title": "GeoJSON",
                    "type": "object",
                    "subtype": "geojson"
                },
                {
                    "title": "No filter",
                    "description": "Don't filter spatially. All data is included in the data cube.",
                    "type": "null"
                }
            ]
        },
        {
            "name": "temporal_extent",
            "description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the temporal interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the temporal interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Also supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
            "schema": [
                {
                    "type": "array",
                    "subtype": "temporal-interval",
                    "minItems": 2,
                    "maxItems": 2,
                    "items": {
                        "anyOf": [
                            {
                                "type": "string",
                                "format": "date-time",
                                "subtype": "date-time"
                            },
                            {
                                "type": "string",
                                "format": "date",
                                "subtype": "date"
                            },
                            {
                                "type": "string",
                                "subtype": "year",
                                "minLength": 4,
                                "maxLength": 4,
                                "pattern": "^\\d{4}$"
                            },
                            {
                                "type": "null"
                            }
                        ]
                    },
                    "examples": [
                        [
                            "2015-01-01T00:00:00Z",
                            "2016-01-01T00:00:00Z"
                        ],
                        [
                            "2015-01-01",
                            "2016-01-01"
                        ]
                    ]
                },
                {
                    "title": "No filter",
                    "description": "Don't filter temporally. All data is included in the data cube.",
                    "type": "null"
                }
            ]
        },
        {
            "name": "bands",
            "description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands`.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.\n\nThe order of the specified array defines the order of the bands in the data cube. f multiple bands match a common name, all matched bands are included in the original order.",
            "schema": [
                {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "subtype": "band-name"
                    }
                },
                {
                    "title": "No filter",
                    "description": "Don't filter bands. All bands are included in the data cube.",
                    "type": "null"
                }
            ],
            "default": null,
            "optional": true
        },
        {
            "name": "properties",
            "description": "Limits the data by metadata properties to include only data in the data cube which all given conditions return `true` for (AND operation).\n\nSpecify key-value-pairs with the key being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The value must a condition (user-defined process) to be evaluated against the collection metadata, see the example.",
            "schema": [
                {
                    "type": "object",
                    "subtype": "metadata-filter",
                    "title": "Filters",
                    "description": "A list of filters to check against. Specify key-value-pairs with the key being the name of the metadata property name and the value being a process evaluated against the metadata values.",
                    "additionalProperties": {
                        "type": "object",
                        "subtype": "process-graph",
                        "parameters": [
                            {
                                "name": "value",
                                "description": "The property value to be checked against.",
                                "schema": {
                                    "description": "Any data type."
                                }
                            }
                        ]
                    }
                },
                {
                    "title": "No filter",
                    "description": "Don't filter by metadata properties.",
                    "type": "null"
                }
            ],
            "default": null,
            "optional": true
        }
    ],
    "returns": {
        "description": "A data cube for further processing. The dimensions and dimension properties (name, type, labels, reference system and resolution) correspond to the collection's metadata, but the dimension labels are restricted as specified in the parameters.",
        "schema": {
            "type": "object",
            "subtype": "raster-cube"
        }
    },
    "examples": [
        {
            "description": "Loading `Sentinel-2B` data from a `Sentinel-2` collection for 2018, but only with cloud cover between 0 and 50%.",
            "arguments": {
                "id": "Sentinel-2",
                "spatial_extent": {
                    "west": 16.1,
                    "east": 16.6,
                    "north": 48.6,
                    "south": 47.2
                },
                "temporal_extent": [
                    "2018-01-01",
                    "2019-01-01"
                ],
                "properties": {
                    "eo:cloud_cover": {
                        "process_graph": {
                            "cc": {
                                "process_id": "between",
                                "arguments": {
                                    "x": {
                                        "from_parameter": "value"
                                    },
                                    "min": 0,
                                    "max": 50
                                },
                                "result": true
                            }
                        }
                    },
                    "platform": {
                        "process_graph": {
                            "pf": {
                                "process_id": "eq",
                                "arguments": {
                                    "x": {
                                        "from_parameter": "value"
                                    },
                                    "y": "Sentinel-2B",
                                    "case_sensitive": false
                                },
                                "result": true
                            }
                        }
                    }
                }
            }
        }
    ],
    "links": [
        {
            "rel": "about",
            "href": "https://proj.org/usage/projections.html",
            "title": "PROJ parameters for cartographic projections"
        },
        {
            "rel": "about",
            "href": "http://www.epsg-registry.org",
            "title": "Official EPSG code registry"
        },
        {
            "rel": "about",
            "href": "http://www.epsg.io",
            "title": "Unofficial EPSG code database"
        },
        {
            "href": "http://www.opengeospatial.org/standards/sfa",
            "rel": "about",
            "title": "Simple Features standard by the OGC"
        },
        {
            "rel": "about",
            "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
            "title": "List of common band names as specified by the STAC specification"
        }
    ]
},
{
    "id": "save_result",
    "summary": "Save processed data to storage",
    "description": "Saves processed data to the local user workspace / data store of the authenticated user. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
    "categories": [
        "cubes",
        "export"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "The data to save.",
            "schema": [
                {
                    "type": "object",
                    "subtype": "raster-cube"
                },
                {
                    "type": "object",
                    "subtype": "vector-cube"
                }
            ]
        },
        {
            "name": "format",
            "description": "The file format to save to. It must be one of the values that the server reports as supported output file formats, which usually correspond to the short GDAL/OGR codes. If the format is not suitable for storing the underlying data structure, a `FormatUnsuitable` exception will be thrown. This parameter is *case insensitive*.",
            "schema": {
                "type": "string",
                "subtype": "output-format"
            }
        },
        {
            "name": "options",
            "description": "The file format parameters to be used to create the file(s). Must correspond to the parameters that the server reports as supported parameters for the chosen `format`. The parameter names and valid values usually correspond to the GDAL/OGR format options.",
            "schema": {
                "type": "object",
                "subtype": "output-format-options"
            },
            "default": {},
            "optional": true
        }
    ],
    "returns": {
        "description": "`false` if saving failed, `true` otherwise.",
        "schema": {
            "type": "boolean"
        }
    },
    "exceptions": {
        "FormatUnsuitable": {
            "message": "Data can't be transformed into the requested output format."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://www.gdal.org/formats_list.html",
            "title": "GDAL Raster Formats"
        },
        {
            "rel": "about",
            "href": "https://www.gdal.org/ogr_formats.html",
            "title": "OGR Vector Formats"
        }
    ]
},
{
    "id": "run_udf",
    "summary": "Run an UDF",
    "description": "Runs an UDF in one of the supported runtime environments.\n\nThe process can either:\n\n1. load and run a locally stored UDF from a file in the workspace of the authenticated user. The path to the UDF file must be relative to the root directory of the user's workspace.\n2. fetch and run a remotely stored and published UDF by absolute URI, for example from [openEO Hub](https://hub.openeo.org)).\n3. run the source code specified inline as string.\n\nThe loaded UDF can be executed in several processes such as ``aggregate_spatial()``, ``apply()``, ``apply_dimension()`` and ``reduce_dimension()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
        "cubes",
        "import",
        "udf"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "The data to be passed to the UDF as array or raster data cube.",
            "schema": [
                {
                    "title": "Raster data cube",
                    "type": "object",
                    "subtype": "raster-cube"
                },
                {
                    "title": "Array",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "description": "Any data type."
                    }
                },
                {
                    "title": "Single Value",
                    "description": "A single value of any data type."
                }
            ]
        },
        {
            "name": "udf",
            "description": "Either source code, an absolute URL or a path to an UDF script.",
            "schema": [
                {
                    "description": "URI to an UDF",
                    "type": "string",
                    "format": "uri",
                    "subtype": "uri"
                },
                {
                    "description": "Path to an UDF uploaded to the server.",
                    "type": "string",
                    "subtype": "file-path"
                },
                {
                    "description": "Source code as string",
                    "type": "string",
                    "subtype": "udf-code"
                }
            ]
        },
        {
            "name": "runtime",
            "description": "An UDF runtime identifier available at the back-end.",
            "schema": {
                "type": "string",
                "subtype": "udf-runtime"
            }
        },
        {
            "name": "version",
            "description": "An UDF runtime version. If set to `null`, the default runtime version specified for each runtime is used.",
            "schema": [
                {
                    "type": "string",
                    "subtype": "udf-runtime-version"
                },
                {
                    "title": "Default runtime version",
                    "type": "null"
                }
            ],
            "default": null,
            "optional": true
        },
        {
            "name": "context",
            "description": "Additional data such as configuration options that should be passed to the UDF.",
            "schema": {
                "type": "object"
            },
            "default": {},
            "optional": true
        }
    ],
    "exceptions": {
        "InvalidVersion": {
            "message": "The specified UDF runtime version is not supported."
        }
    },
    "returns": {
        "description": "The data processed by the UDF.\n\n* Returns a raster data cube, if a raster data cube is passed for `data`. Details on the dimensions and dimension properties (name, type, labels, reference system and resolution) depend on the UDF.\n* If an array is passed for `data`, the returned value can be of any data type, but is exactly what the UDF returns.",
        "schema": [
            {
                "title": "Raster data cube",
                "type": "object",
                "subtype": "raster-cube"
            },
            {
                "title": "Any",
                "description": "Any data type."
            }
        ]
    }
},
{
    "id": "filter_bands",
    "summary": "Filter the bands by name",
    "description": "Filters the bands in the data cube so that bands that don't match any of the criteria are dropped from the data cube. The data cube is expected to have only one dimension of type `bands`. Fails with a `DimensionMissing` error if no such dimension exists.\n\nThe following criteria can be used to select bands:\n\n* `bands`: band name or common band name (e.g. `B01`, `B8A`, `red` or `nir`)\n* `wavelengths`: ranges of wavelengths in micrometres (?m) (e.g. 0.5 - 0.6)\n\nAll these information are exposed in the band metadata of the collection. To keep algorithms interoperable it is recommended to prefer the common bands names or the wavelengths over collection and/or back-end specific band names.\n\nIf multiple criteria are specified, any of them must match and not all of them, i.e. they are combined with an OR-operation. If no criteria is specified, the `BandFilterParameterMissing` exception must be thrown.\n\n**Important:** The order of the specified array defines the order of the bands in the data cube, which can be important for subsequent processes. If multiple bands are matched by a single criterion (e.g. a range of wavelengths), they stay in the original order.",
    "categories": [
        "cubes",
        "filter"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "A data cube with bands.",
            "schema": {
                "type": "object",
                "subtype": "raster-cube"
            }
        },
        {
            "name": "bands",
            "description": "A list of band names. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority.\n\nThe order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order.",
            "schema": {
                "type": "array",
                "items": {
                    "type": "string",
                    "subtype": "band-name"
                }
            },
            "default": [],
            "optional": true
        },
        {
            "name": "wavelengths",
            "description": "A list of sub-lists with each sub-list consisting of two elements. The first element is the minimum wavelength and the second element is the maximum wavelength. Wavelengths are specified in micrometres (?m).\n\nThe order of the specified array defines the order of the bands in the data cube. If multiple bands match the wavelengths, all matched bands are included in the original order.",
            "schema": {
                "type": "array",
                "items": {
                    "type": "array",
                    "minItems": 2,
                    "maxItems": 2,
                    "items": {
                        "type": "number"
                    },
                    "examples": [
                        [
                            [
                                0.45,
                                0.5
                            ],
                            [
                                0.6,
                                0.7
                            ]
                        ]
                    ]
                }
            },
            "default": [],
            "optional": true
        }
    ],
    "returns": {
        "description": "A data cube limited to a subset of its original bands. The dimensions and dimension properties (name, type, labels, reference system and resolution) remain unchanged, except that the dimension of type `bands` has less (or the same) dimension labels.",
        "schema": {
            "type": "object",
            "subtype": "raster-cube"
        }
    },
    "exceptions": {
        "BandFilterParameterMissing": {
            "message": "The process 'filter_bands' requires any of the parameters 'bands', 'common_names' or 'wavelengths' to be set."
        },
        "DimensionMissing": {
            "message": "A band dimension is missing."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
            "title": "List of common band names as specified by the STAC specification"
        }
    ]
},
{
    "id": "filter_bbox",
    "summary": "Spatial filter using a bounding box",
    "description": "Limits the data cube to the specified bounding box.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with the bounding box (as defined in the Simple Features standard by the OGC).",
    "categories": [
        "cubes",
        "filter"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "subtype": "raster-cube"
            }
        },
        {
            "name": "extent",
            "description": "A bounding box, which may include a vertical axis (see `base` and `height`).",
            "schema": {
                "type": "object",
                "subtype": "bounding-box",
                "required": [
                    "west",
                    "south",
                    "east",
                    "north"
                ],
                "properties": {
                    "west": {
                        "description": "West (lower left corner, coordinate axis 1).",
                        "type": "number"
                    },
                    "south": {
                        "description": "South (lower left corner, coordinate axis 2).",
                        "type": "number"
                    },
                    "east": {
                        "description": "East (upper right corner, coordinate axis 1).",
                        "type": "number"
                    },
                    "north": {
                        "description": "North (upper right corner, coordinate axis 2).",
                        "type": "number"
                    },
                    "base": {
                        "description": "Base (optional, lower left corner, coordinate axis 3).",
                        "type": [
                            "number",
                            "null"
                        ],
                        "default": null
                    },
                    "height": {
                        "description": "Height (optional, upper right corner, coordinate axis 3).",
                        "type": [
                            "number",
                            "null"
                        ],
                        "default": null
                    },
                    "crs": {
                        "description": "Coordinate reference system of the extent, specified as as [EPSG code](http://www.epsg-registry.org/), [WKT2 (ISO 19162) string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html) or [PROJ definition (deprecated)](https://proj.org/usage/quickstart.html). Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                        "anyOf": [
                            {
                                "title": "EPSG Code",
                                "type": "integer",
                                "subtype": "epsg-code",
                                "minimum": 1000,
                                "examples": [
                                    3857
                                ]
                            },
                            {
                                "title": "WKT2",
                                "type": "string",
                                "subtype": "wkt2-definition"
                            },
                            {
                                "title": "PROJ definition",
                                "type": "string",
                                "subtype": "proj-definition",
                                "deprecated": true
                            }
                        ],
                        "default": 4326
                    }
                }
            }
        }
    ],
    "returns": {
        "description": "A data cube restricted to the bounding box. The dimensions and dimension properties (name, type, labels, reference system and resolution) remain unchanged, except that the spatial dimensions have less (or the same) dimension labels.",
        "schema": {
            "type": "object",
            "subtype": "raster-cube"
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://proj.org/usage/projections.html",
            "title": "PROJ parameters for cartographic projections"
        },
        {
            "rel": "about",
            "href": "http://www.epsg-registry.org",
            "title": "Official EPSG code registry"
        },
        {
            "rel": "about",
            "href": "http://www.epsg.io",
            "title": "Unofficial EPSG code database"
        },
        {
            "href": "http://www.opengeospatial.org/standards/sfa",
            "rel": "about",
            "title": "Simple Features standard by the OGC"
        }
    ]
},
{
    "id": "filter_temporal",
    "summary": "Temporal filter for a temporal intervals",
    "description": "Limits the data cube to the specified interval of dates and/or times.\n\nMore precisely, the filter checks whether the temporal dimension label is greater than or equal to the lower boundary (start date/time) and the temporal dimension label is less than the value of the upper boundary (end date/time). This corresponds to a left-closed interval, which contains the lower boundary but not the upper boundary.\n\nIf the dimension is set to `null` (it's the default value), the data cube is expected to only have one temporal dimension.",
    "categories": [
        "cubes",
        "filter"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "subtype": "raster-cube"
            }
        },
        {
            "name": "extent",
            "description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the temporal interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the temporal interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Also supports open intervals by setting one of the boundaries to `null`, but never both.",
            "schema": {
                "type": "array",
                "subtype": "temporal-interval",
                "minItems": 2,
                "maxItems": 2,
                "items": {
                    "anyOf": [
                        {
                            "type": "string",
                            "format": "date-time",
                            "subtype": "date-time"
                        },
                        {
                            "type": "string",
                            "format": "date",
                            "subtype": "date"
                        },
                        {
                            "type": "string",
                            "subtype": "year",
                            "minLength": 4,
                            "maxLength": 4,
                            "pattern": "^\\d{4}$"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "examples": [
                    [
                        "2015-01-01T00:00:00Z",
                        "2016-01-01T00:00:00Z"
                    ],
                    [
                        "2015-01-01",
                        "2016-01-01"
                    ]
                ]
            }
        },
        {
            "name": "dimension",
            "description": "The name of the temporal dimension to filter on. If the dimension is not set or is set to `null`, the filter applies to all temporal dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.",
            "schema": {
                "type": [
                    "string",
                    "null"
                ]
            },
            "default": null,
            "optional": true
        }
    ],
    "returns": {
        "description": "A data cube restricted to the specified temporal extent. The dimensions and dimension properties (name, type, labels, reference system and resolution) remain unchanged, except that the given temporal dimension(s) have less (or the same) dimension labels.",
        "schema": {
            "type": "object",
            "subtype": "raster-cube"
        }
    },
    "exceptions": {
        "DimensionNotAvailable": {
            "message": "A dimension with the specified name does not exist."
        }
    }
},
{
    "id": "ndvi",
    "summary": "Normalized Difference Vegetation Index",
    "description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with a dimension of type `bands` or a `DimensionAmbiguous` error is thrown otherwise. By default, the dimension must have at least two bands with the common names `red` and `nir` assigned or the user need to specify the parameters `nir` and `red`. Otherwise either the error `NirBandAmbiguous` or `RedBandAmbiguous` is thrown. The common names for each band are specified in the collection's band metadata and are *not* equal to the band names.\n\nBy default, the dimension of type `bands` is dropped by this process. To keep the dimension specify a new band name in the parameter `target_band`. This adds a new dimension label with the specified name to the dimension, which can be used to access the computed values. If a band with the specified name exists, a `BandExists` is thrown.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common names (`red`/`nir`) specified in the metadata.",
    "categories": [
        "math > indices",
        "vegetation indices"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
            "schema": {
                "type": "object",
                "subtype": "raster-cube"
            }
        },
        {
            "name": "nir",
            "description": "The name of the NIR band. Defaults to the band that has the common name `nir` assigned.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.",
            "schema": {
                "type": "string",
                "subtype": "band-name"
            },
            "default": "nir",
            "optional": true
        },
        {
            "name": "red",
            "description": "The name of the red band. Defaults to the band that has the common name `red` assigned.\n\nEither the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands) can be specified. If unique band name and common name conflict, the unique band name has higher priority.",
            "schema": {
                "type": "string",
                "subtype": "band-name"
            },
            "default": "red",
            "optional": true
        },
        {
            "name": "target_band",
            "description": "By default, the dimension of type `bands` is dropped. To keep the dimension specify a new band name in this parameter so that a new dimension label with the specified name will be added for the computed values.",
            "schema": [
                {
                    "type": "string",
                    "pattern": "^\\w+$"
                },
                {
                    "type": "null"
                }
            ],
            "default": null,
            "optional": true
        }
    ],
    "returns": {
        "description": "A raster data cube containing the computed NDVI values. The structure of the data cube differs depending on the value passed to `target_band`:\n\n* `target_band` is `null`: The data cube does not contain the dimension of type `bands` any more, the number of dimensions decreases by one. The dimension properties (name, type, labels, reference system and resolution) for all other dimensions remain unchanged.\n* `target_band` is a string: The data cube keeps the same dimensions. The dimension properties remain unchanged, but the number of dimension labels for the dimension of type `bands` increases by one. The additional label is named as specified in `target_band`.",
        "schema": {
            "type": "object",
            "subtype": "raster-cube"
        }
    },
    "exceptions": {
        "NirBandAmbiguous": {
            "message": "The NIR band can't be resolved, please specify a band name."
        },
        "RedBandAmbiguous": {
            "message": "The red band can't be resolved, please specify a band name."
        },
        "DimensionAmbiguous": {
            "message": "dimension of type `bands` is not available or is ambiguous.."
        },
        "BandExists": {
            "message": "A band with the specified target name exists."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
            "title": "NDVI explained by Wikipedia"
        },
        {
            "rel": "about",
            "href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
            "title": "NDVI explained by NASA"
        },
        {
            "rel": "about",
            "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
            "title": "List of common band names as specified by the STAC specification"
        }
    ]
},
{
    "id": "count",
    "summary": "Count the number of elements",
    "description": "Gives the number of elements in an array that matches the specified condition.\n\n**Remarks:**\n\n* Counts the number of valid elements by default (`condition` is set to `null`). A valid element is every element for which ``is_valid()`` returns `true`.\n* To count all elements in a list set the `condition` parameter to boolean `true`.",
    "categories": [
        "arrays",
        "reducer"
    ],
    "parameters": [
        {
            "name": "data",
            "description": "An array with elements of any data type.",
            "schema": {
                "type": "array",
                "items": {
                    "description": "Any data type is allowed."
                }
            }
        },
        {
            "name": "condition",
            "description": "A condition consists of one ore more processes, which in the end return a boolean value. It is evaluated against each element in the array. An element is counted only if the condition returns `true`. Defaults to count valid elements in a list (see ``is_valid()``). Setting this parameter to boolean `true` counts all elements in the list.",
            "schema": [
                {
                    "title": "Condition",
                    "description": "A logical expression that is evaluated against each element in the array.",
                    "type": "object",
                    "subtype": "process-graph",
                    "parameters": [
                        {
                            "name": "x",
                            "description": "The value of the current element being processed.",
                            "schema": {
                                "description": "Any data type."
                            }
                        },
                        {
                            "name": "context",
                            "description": "Additional data passed by the user.",
                            "schema": {
                                "description": "Any data type."
                            },
                            "optional": true,
                            "default": null
                        }
                    ]
                },
                {
                    "title": "All elements",
                    "description": "Boolean `true` counts all elements in the list.",
                    "type": "boolean",
                    "const": true
                },
                {
                    "title": "Valid elements",
                    "description": "`null` counts valid elements in the list.",
                    "type": "null"
                }
            ],
            "default": null,
            "optional": true
        },
        {
            "name": "context",
            "description": "Additional data to be passed to the condition.",
            "schema": {
                "description": "Any data type."
            },
            "optional": true,
            "default": null
        }
    ],
    "returns": {
        "description": "The counted number of elements.",
        "schema": {
            "type": "number"
        }
    },
    "examples": [
        {
            "arguments": {
                "data": []
            },
            "returns": 0
        },
        {
            "arguments": {
                "data": [
                    1,
                    0,
                    3,
                    2
                ]
            },
            "returns": 4
        },
        {
            "arguments": {
                "data": [
                    "ABC",
                    null
                ]
            },
            "returns": 1
        },
        {
            "arguments": {
                "data": [
                    false,
                    null
                ],
                "condition": true
            },
            "returns": 2
        },
        {
            "arguments": {
                "data": [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    null
                ],
                "condition": {
                    "gt": {
                        "process_id": "gt",
                        "arguments": {
                            "x": {
                                "from_parameter": "element"
                            },
                            "y": 2
                        },
                        "result": true
                    }
                }
            },
            "returns": 3
        }
    ]
}

]